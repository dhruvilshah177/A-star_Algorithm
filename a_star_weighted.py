from queue import PriorityQueue
from heapq import heappush, heappop
from collections import defaultdict
import math
import numpy as np
import os
import time


# Heuristic Function based on Manhattan Distance
def heuristic(new_state, goal):
    x1, y1 = new_state
    x2, y2 = goal
    x1, x2, y1, y2 = int(x1), int(x2), int(y1), int(y2)
    return abs(x1 - x2) + abs(y1 - y2)

# Euclidean Distance
def eucl_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    x1, x2, y1, y2 = int(x1), int(x2), int(y1), int(y2)
    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

# Diagonal Distance
def diagonal_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    x1, x2, y1, y2 = int(x1), int(x2), int(y1), int(y2)
    return max(abs(x1 - x2), abs(y1 - y2))


def get_cost(grid, current_x, current_y, next_x, next_y, dir):
    current_type = grid[current_x][current_y]
    next_type = grid[next_x][next_y]

    # any 0's lead to very high cost.
    if next_type == '0':
        return float("inf")
    # 1-1
    if current_type == '1' and next_type == '1':
        return 1 if dir == 'side' else math.sqrt(2)
    # 2-2
    elif current_type == '2' and next_type == '2':
        return 2 if dir == 'side' else math.sqrt(8)
    # a-a
    elif current_type == 'a' and next_type == 'a':
        return .25
    # b-b
    elif current_type == 'b' and next_type == 'b':
        return .5
    # 2-1 or 1-2
    elif (current_type == '1' and next_type == '2') or (current_type == '2' and next_type == '1'):
        return 1.5 if dir == 'side' else (math.sqrt(2) + math.sqrt(8)) / 2
    # a-1 or 1-a
    elif (current_type == '1' and next_type == 'a') or (current_type == 'a' and next_type == '1'):
        return 1 if dir == 'side' else math.sqrt(2)
    # a-2 or 2-a
    elif (current_type == '2' and next_type == 'a') or (current_type == 'a' and next_type == '2'):
        return 1.5 if dir == 'side' else (math.sqrt(2) + math.sqrt(8)) / 2
    # b-1 or 1-b
    elif (current_type == '1' and next_type == 'b') or (current_type == 'b' and next_type == '1'):
        return 1.5 if dir == 'side' else (math.sqrt(2) + math.sqrt(8)) / 2
    # b-2 or 2-b
    elif (current_type == '2' and next_type == 'b') or (current_type == 'b' and next_type == '2'):
        return 2 if dir == 'side' else math.sqrt(8)
    # a-b or b-a
    elif (current_type == 'a' and next_type == 'b') or (current_type == 'b' and next_type == 'a'):
        return .375


def update_vertex(cur_state, new_state, g_score, f_score, pq, came_from, grid, dir_, goal, weight):
    # let temporary g_score be cost + g_score of the node we came from i.e current node
    temp_g_score = g_score[cur_state] + get_cost(grid, cur_state[0], cur_state[1], new_state[0], new_state[1], dir_)

    # if temp_g_score is less than the score we had for this node, set that score
    if temp_g_score < g_score[(new_state[0], new_state[1])]:
        g_score[(new_state[0], new_state[1])] = temp_g_score

        # to keep track of where we came from to this node - the path
        came_from[new_state] = cur_state

        if new_state in pq:
            heap_item = (f_score[new_state], new_state)
            pq.remove(heap_item)

        new_f_score_val = temp_g_score + (weight * heuristic(new_state, goal))
        f_score[new_state] = new_f_score_val
        heappush(pq, (new_f_score_val, new_state))

    return g_score, f_score, pq, came_from


def weighted_a_star_helper(pq, start, goal, f_score, g_score, came_from, pq_set, grid, num_nodes_expanded, weight, closed):
    while len(pq) > 0:
        # get current node (f_score, (x, y))
        current = heappop(pq)

        num_nodes_expanded += 1
        x_current = int(current[1][0])
        y_current = int(current[1][1])

        # If we reached the goal
        if (x_current, y_current) == goal:
            goal_reached = True
            return came_from, num_nodes_expanded

        # pq_set.remove(current[1])
        closed.add(current[1])

        # for traversing in 8 directions: right, left, down, up, down-right, down-left, up-left, up-right in order
        x = [0, 0, 1, -1, 1, 1, -1, -1]
        y = [1, -1, 0, 0, 1, -1, -1, 1]
        direction = ['side', 'side', 'side', 'side', 'diagonal', 'diagonal', 'diagonal', 'diagonal']

        # traversing 4 neighbor nodes
        for row, col, dir_ in zip(x, y, direction):
            new_x = x_current + row
            new_y = y_current + col
            new_state = (new_x, new_y)
            # check if node is in boundaries of grid
            if 0 <= new_x < 120 and 0 <= new_y < 160:
                if (new_x, new_y) not in closed:
                    g_score, f_score, pq, came_from = update_vertex(current[1], new_state, g_score, f_score, pq, came_from, grid, dir_, goal, weight)

    print("No path found")
    return None


def main():
    # Priority Queue
    pq = []

    # Assuming map.txt follows the same format as generated by create_world.py
    # Getting the start, goal and the grid as a 2d list
    with open("map.txt") as textFile:
        first_line = textFile.readline()
        second_line = textFile.readline()

        x_start, y_start = first_line.split()
        x_goal, y_goal = second_line.split()

        grid = [line.split() for line in textFile]

    # g_score of nodes using dictionary with default value "inf"
    start = (int(x_start), int(y_start))
    goal = (int(x_goal), int(y_goal))

    # g_score[n] is the cost of the cheapest path from start to n currently known.
    g_score = defaultdict(lambda: float("inf"))
    g_score[start] = 0

    # #  For node n, f_score[n] := g_score[n] + heuristic(n). f_score[n] represents our current best guess as to
    # #  how short a path from start to finish can be if it goes through n.
    f_score = defaultdict(lambda: float("inf"))
    f_score[start] = g_score[start] + heuristic(start, goal)

    # put start node into Priority Queue
    key = g_score[start] + heuristic(start, goal)
    heappush(pq, (key, start))

    # For node n, came_from[n] is the node immediately preceding it on the cheapest path from start
    # to n currently known.
    came_from = dict()

    pq_set = set()
    pq_set.add(start)
    closed = set()

    #goal_reached = False
    weight = float(input("Enter the weight for the weighted A* : "))

    num_nodes_expanded = 0

    start_time = time.time()

    came_from, num_nodes_expanded = weighted_a_star_helper(pq, start, goal, f_score, g_score, came_from, pq_set, grid, num_nodes_expanded, weight, closed)

    #if goal_reached:
    time_taken = time.time() - start_time
    print("Path Found!")

    # Setting the value 'p' in the grid for our path found
    x, y = came_from[goal]
    while True:
        if (x, y) == start:
            break
        grid[x][y] = 'p'
        end = (x, y)
        x, y = came_from[end]

    path_counter = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 'p':
                path_counter += 1
    #else:
    #    print("No Path found")

    print("Path Length: ", path_counter)
    print("Number of Nodes expanded: ", num_nodes_expanded)
    print("The weighted A* took", time_taken, "seconds to run")

    np.savetxt("wAstar_finished_map.txt", grid, fmt="%s")
    #create_world code to send in starting coords
    file_name = "wAstar_finished_map.txt"
    dummy_file = file_name + '.bak'
    # open original file in read mode and dummy file in write mode
    with open(file_name, 'r') as read_obj, open(dummy_file, 'w') as write_obj:
        # Write given line to the dummy file
        write_obj.write(str(x_start) + ' ' + str(y_start) + '\n')
        write_obj.write(str(x_goal) + ' ' + str(y_goal) + '\n')
        # Read lines from original file one by one and append them to the dummy file
        for line in read_obj:
            write_obj.write(line)
    # remove original file
    os.remove(file_name)
    # Rename dummy file as the original file
    os.rename(dummy_file, file_name)


main()